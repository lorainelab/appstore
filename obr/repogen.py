#
# Author: Sameer Shanbhag
# Email: sshanbh1@uncc.edu
#

from django.conf import settings
from xml.etree import ElementTree as ET
import re
from submit_app.models import AppPending
from apps.models import App


def xml_writer(elem):
    """
    Write to XML string for the Element.
    """
    tree = ET.ElementTree(elem)
    tree.write(open(settings.MEDIA_ROOT + '/pending_releases/repository.xml', 'wb'))


def split(word):
    """
        Split the String in to characters for processing
    """
    return [char for char in word]


def custom_split(char_array):
    """
    Custom Splitting the String to Get Import Statements
    :param char_array: List of Characters
    :return: List of Import Statements
    """
    custom_list = []
    temp = ''
    for i in range(0, len(char_array)):
        if i == 0:
            temp += char_array[i]
        elif i == len(char_array) - 1:
            temp += char_array[i]
            custom_list.append(temp)
            temp = ''
        else:
            if char_array[i] == ',':
                if char_array[i - 1].isdigit() and char_array[i + 1].isdigit():
                    temp += char_array[i]
                else:
                    custom_list.append(temp)
                    temp = ''
            else:
                temp += char_array[i]
    return custom_list


def generate_xml_from_obr(dict_ver):
    # Removing Namespace definition for further use (If we plan on using the XML Generated by BND Tools as Primary)
    xml_bnd = re.sub(' xmlns="[^"]+"', '', dict_ver.xml_bnd, count=1)
    xml_bnd = re.sub(' namespace=\"(.*)\"', '', xml_bnd)

    packages = []
    element = ET.fromstring(xml_bnd)
    resource = element.find('resource')

    directive = resource.findall('requirement')

    for i in directive:
        a = i.find('directive')
        packages.append(re.sub('osgi.wiring.', '', a.attrib["value"]))
    return packages


def get_fullname(input):
    input = input.lower()
    input = input.replace(' ', '')
    return input


def generate_xml(dict_ver, tree, state):
    """
    :param state: Pending or Released ?
    :param tree: Element Object
    :param dict_ver: Object of Pending App
    :return: Nothing | Generates the XML at a given location
    """
    if tree != "":
        tree = ET.tostring(tree, encoding='unicode')
        elemt = ET.fromstring(tree)
        repository = elemt
    else:
        repository = ET.Element('repository')
        repository.set('lastmodified', dict_ver.lastmodified)

    resource = ET.SubElement(repository, 'resource')
    resource.set('id', dict_ver.symbolicname + '\\' + dict_ver.version)
    resource.set('symbolicname', dict_ver.symbolicname)
    resource.set('presentationname', dict_ver.fullname)
    if state == 'pending':
        resource.set('uri', '/media/pending_releases/' + dict_ver.symbolicname + '-' + dict_ver.version + '.jar')
    else:
        resource.set('uri', '/media/' + get_fullname(dict_ver.fullname) + '/' + 'releases' + '/' + dict_ver.version +
                     '/' + dict_ver.symbolicname + '-' + dict_ver.version + '.jar')
    resource.set('version', dict_ver.version)

    description = ET.SubElement(resource, 'description')
    description.text = dict_ver.details

    # size = SubElement(resource, 'size')
    # size.text = 'Bundle-Size'

    capability = ET.SubElement(resource, 'capability')
    capability.set('name', 'bundle')

    p = ET.SubElement(capability, 'p')
    p.set('n', 'symbolicname')
    p.set('v', dict_ver.symbolicname,)

    p = ET.SubElement(capability, 'p')
    p.set('n', 'presentationname')
    p.set('v', dict_ver.fullname)

    p = ET.SubElement(capability, 'p')
    p.set('n', 'version')
    p.set('v', dict_ver.version)

    p = ET.SubElement(capability, 'p')
    p.set('n', 'manifestversion')
    p.set('v', dict_ver.manifest_version)

    regex = r'version=\"\[(.*)\)'

    get_ist = custom_split(split(dict_ver.import_packages))

    for i in get_ist:
        require = ET.SubElement(resource, 'require')
        require.set('name', 'package')
        if i.count('version') > 0:
            temp = i.split(';')

            search_obj = re.search(regex, temp[1])

            version = search_obj.group(1).split(',')
            require.set('filter', '(&(package=' + temp[0] + ')' + '(version>=' + version[0] + ')(!(version>=' +
                        version[1] + ')))')
        else:
            require.set('filter', '(&(package=' + i + '))')
        require.set('extend', 'false')
        require.set('multiple', 'false')
        require.set('optional', 'false')
        require.text = 'Import package ' + i
    # return ET.tostring(repository, encoding='unicode')
    return repository


def main(status):
    if status == 'pending':
        all_entries = AppPending.objects.all()
    else:
        all_entries = App.objects.all()

    tree = ""

    if len(all_entries) > 0:
        for entry in all_entries:
            tree = generate_xml(entry, tree, status)
        return tree
    else:
        repository = ET.Element('repository')
        resource = ET.SubElement(repository, 'resource')
        return repository
