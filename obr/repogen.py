#
# Author: Sameer Shanbhag
# Email: sshanbh1@uncc.edu
#

from django.conf import settings
from xml.etree import ElementTree as ET
import re
import base64
from submit_app.models import AppPending
from apps.models import App


"""
These function will not be used, we can clean this once the work flow is defined and stable.

CURRENTLY USELESS FUNCTIONS START
"""
def xml_writer(elem):
    """
    Write to XML string for the Element.
    """
    tree = ET.ElementTree(elem)
    tree.write(open(settings.MEDIA_ROOT + '/pending_releases/repository.xml', 'wb'))


def split(word):
    """
        Split the String in to characters for processing
    """
    return [char for char in word]


def custom_split(char_array):
    """
    Custom Splitting the String to Get Import Statements
    :param char_array: List of Characters
    :return: List of Import Statements
    """
    custom_list = []
    temp = ''
    for i in range(0, len(char_array)):
        if i == 0:
            temp += char_array[i]
        elif i == len(char_array) - 1:
            temp += char_array[i]
            custom_list.append(temp)
            temp = ''
        else:
            if char_array[i] == ',':
                if char_array[i - 1].isdigit() and char_array[i + 1].isdigit():
                    temp += char_array[i]
                else:
                    custom_list.append(temp)
                    temp = ''
            else:
                temp += char_array[i]
    return custom_list


def generate_xml_from_obr(dict_ver):
    # Removing Namespace definition for further use (If we plan on using the XML Generated by BND Tools as Primary)
    xml_bnd = re.sub(' xmlns="[^"]+"', '', dict_ver.xml_bnd, count=1)
    xml_bnd = re.sub(' namespace=\"(.*)\"', '', xml_bnd)

    packages = []
    element = ET.fromstring(xml_bnd)
    resource = element.find('resource')

    directive = resource.findall('requirement')

    for i in directive:
        a = i.find('directive')
        packages.append(re.sub('osgi.wiring.', '', a.attrib["value"]))
    return packages


def generate_xml(dict_ver, tree, state):
    """
    :param state: Pending or Released ?
    :param tree: Element Object
    :param dict_ver: Object of Pending App
    :return: Nothing | Generates the XML at a given location
    """
    if tree != "":
        tree = ET.tostring(tree, encoding='unicode')
        elemt = ET.fromstring(tree)
        repository = elemt
    else:
        repository = ET.Element('repository')
        repository.set('lastmodified', dict_ver.lastmodified)

    resource = ET.SubElement(repository, 'resource')
    resource.set('id', dict_ver.symbolicname + '\\' + dict_ver.version)
    resource.set('symbolicname', dict_ver.symbolicname)
    resource.set('presentationname', dict_ver.fullname)
    if state == 'pending':
        resource.set('uri', '/media/pending_releases/' + dict_ver.release_file_name)
    else:
        resource.set('uri', '/media/' + get_fullname(dict_ver.fullname) + '/' + 'releases' + '/' + dict_ver.version + '/' + dict_ver.release_file_name)
    resource.set('version', dict_ver.version)

    description = ET.SubElement(resource, 'description')
    temp = dict_ver.details.encode('utf-8')
    description.text = base64.b64encode(temp).decode('utf-8')
    # print(base64.b64encode(dict_ver.details.decode('utf-8')))
    # size = SubElement(resource, 'size')
    # size.text = 'Bundle-Size'

    capability = ET.SubElement(resource, 'capability')
    capability.set('name', 'bundle')

    p = ET.SubElement(capability, 'p')
    p.set('n', 'symbolicname')
    p.set('v', dict_ver.symbolicname,)

    p = ET.SubElement(capability, 'p')
    p.set('n', 'presentationname')
    p.set('v', dict_ver.fullname)

    p = ET.SubElement(capability, 'p')
    p.set('n', 'version')
    p.set('v', dict_ver.version)

    p = ET.SubElement(capability, 'p')
    p.set('n', 'manifestversion')
    p.set('v', dict_ver.manifest_version)

    regex = r'version=\"\[(.*)\)'

    get_ist = custom_split(split(dict_ver.import_packages))

    for i in get_ist:
        require = ET.SubElement(resource, 'require')
        require.set('name', 'package')
        if i.count('version') > 0:
            temp = i.split(';')
            for item in temp[1:]:
                search_obj = re.search(regex, item)
                if search_obj is None:
                    pass
                else:
                    version = search_obj.group(1).split(',')
                    require.set('filter', '(&(package=' + temp[0] + ')' + '(version>=' + version[0] + ')(!(version>=' +
                                version[1] + ')))')
        else:
            require.set('filter', '(&(package=' + i + '))')
        require.set('extend', 'false')
        require.set('multiple', 'false')
        require.set('optional', 'false')
        require.text = 'Import package ' + i
    # return ET.tostring(repository, encoding='unicode')
    return repository


"""
CURRENTLY USELESS FUNCTIONS END
"""

def get_fullname(input):
    """
    :param input: Complete Name of the application
    :return: lower cased name
    """
    input = input.lower()
    input = input.replace(' ', '')
    return input


def xml_generator(dict_ver, gen_tree, tree, state):
    """
    :param gen_tree: Final Element Tree After each Iteration
    :param dict_ver: App Object Data
    :param tree: Element Tree Retrieved from Jar
    :param state: Pending or Released ?
    :return: Nothing | Generates the XML at a given location
    """
    gen_tree = ET.tostring(gen_tree, encoding='unicode')
    gen_tree = ET.fromstring(gen_tree)
    super_tree = gen_tree

    tree = ET.tostring(tree, encoding='unicode')
    tree = ET.fromstring(tree)
    cur_tree = tree

    current_resource = cur_tree.find('resource')
    if state == 'pending':
        current_resource.set('uri', '/media/pending_releases/' + dict_ver.release_file_name)
    else:
        current_resource.set('uri', '/media/' + get_fullname(dict_ver.fullname) + '/' + 'releases' + '/' + dict_ver.version +
                             '/' + dict_ver.release_file_name)

    super_tree.append(current_resource)
    return super_tree


def initial_generation(dict_ver, state):
    """
    :param dict_ver: App Info Object
    :param tree: Element Object
    :param state: Pending or Released ?
    :return: ElementTree
    """
    element_tree = ET.fromstring(dict_ver.repository_xml)
    current_resource = element_tree.find('resource')
    if state == 'pending':
        current_resource.set('uri', '/media/pending_releases/' + dict_ver.release_file_name)
    else:
        current_resource.set('uri', '/media/' + get_fullname(
            dict_ver.fullname) + '/' + 'releases' + '/' + dict_ver.version + '/' + dict_ver.release_file_name)
    return element_tree


def main(status):
    if status == 'pending':
        all_entries = AppPending.objects.all()
    else:
        all_entries = App.objects.all()

    gen_tree = ""

    if len(all_entries) > 0:
        for i in range(0, len(all_entries)):
            if i == 0:
                gen_tree = initial_generation(all_entries[i], status)
            else:
                tree = ET.fromstring(all_entries[i].repository_xml)
                gen_tree = xml_generator(all_entries[i], gen_tree, tree, status)
        return gen_tree
    else:
        repository = ET.Element('repository')
        resource = ET.SubElement(repository, 'resource')
        return repository
